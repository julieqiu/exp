package surfer

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/julieqiu/exp/surfer/internal/sidekick/api"
	"github.com/julieqiu/exp/surfer/internal/sidekick/config"
	"github.com/julieqiu/exp/surfer/internal/gcloudyaml"
	"github.com/julieqiu/exp/surfer/internal/gcloud"
	"github.com/julieqiu/exp/surfer/internal/sidekick/parser"
	"gopkg.in/yaml.v3"
)

// Generate generates gcloud surface definitions from a gcloud.yaml configuration file.
func Generate(googleapis, gcloudYAML, output string) error {
	fmt.Printf("Generating gcloud surfaces...\n")
	fmt.Printf("  googleapis: %s\n", googleapis)
	fmt.Printf("  gcloud-yaml: %s\n", gcloudYAML)
	fmt.Printf("  output: %s\n", output)

	// Step 1: Parse gcloud.yaml file
	gcloudConfig, err := parseGcloudYAML(gcloudYAML)
	if err != nil {
		return fmt.Errorf("failed to parse gcloud.yaml: %w", err)
	}

	fmt.Printf("\nParsed configuration:\n")
	fmt.Printf("  service: %s\n", gcloudConfig.ServiceName)
	fmt.Printf("  apis: %d\n", len(gcloudConfig.APIs))

	// Step 2: Create config for parser
	serviceNameParts := strings.Split(gcloudConfig.ServiceName, ".")
	serviceDir := "google/cloud/" + serviceNameParts[0]
	if len(gcloudConfig.APIs) > 0 {
		serviceDir = filepath.Join(serviceDir, gcloudConfig.APIs[0].APIVersion)
	}

	cfg := &config.Config{
		Gcloud: gcloudConfig,
		General: config.GeneralConfig{
			SpecificationFormat: "protobuf",
			SpecificationSource: serviceDir,
		},
		Source: map[string]string{
			"googleapis-root": googleapis,
		},
	}

	// Step 3: Build API model
	fmt.Printf("\nBuilding API model from protos in %s...\n", serviceDir)
	model, err := parser.CreateModel(cfg)
	if err != nil {
		return fmt.Errorf("failed to create API model: %w", err)
	}
	fmt.Printf("  Created API model for: %s\n", model.Name)
	fmt.Printf("  Services: %d\n", len(model.Services))

	// Step 4: Generate command YAML files
	fmt.Printf("\nGenerating command YAML files...\n")
	if err := generateCommands(model, gcloudConfig, output); err != nil {
		return fmt.Errorf("failed to generate commands: %w", err)
	}

	fmt.Printf("\nâœ“ Generation complete!\n")
	return nil
}

func parseGcloudYAML(path string) (*gcloudyaml.Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var cfg gcloudyaml.Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to unmarshal YAML: %w", err)
	}

	return &cfg, nil
}

// generateCommands generates gcloud command YAML files
func generateCommands(model *api.API, cfg *gcloudyaml.Config, outputDir string) error {
	serviceName := strings.Split(cfg.ServiceName, ".")[0]
	serviceDir := filepath.Join(outputDir, serviceName)

	// Filter out nil services
	var validServices []*api.Service
	for _, s := range model.Services {
		if s != nil {
			validServices = append(validServices, s)
		}
	}

	// Create a set of methods to exclude from generation
	methodsToExclude := make(map[string]bool)
	if cfg.APIs != nil {
		for _, apiCfg := range cfg.APIs {
			for _, filter := range apiCfg.MethodGenerationFilters {
				if !filter.Include {
					methodsToExclude["."+filter.Selector] = true
				}
			}
		}
	}

	for _, service := range validServices {
		if service == nil || service.Name == "" {
			continue
		}
		resourceName := strings.TrimSuffix(service.Name, "Service")
		partialsDir := filepath.Join(serviceDir, "_partials")

		if err := os.MkdirAll(partialsDir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", partialsDir, err)
		}

		for _, method := range service.Methods {
			if methodsToExclude[method.ID] {
				continue
			}
			cmdName := gcloud.DeriveCommandName(method.Name)
			if err := generateCommandFiles(serviceDir, partialsDir, cmdName, method, cfg); err != nil {
				return err
			}
		}
		fmt.Printf("  Generated commands for: %s\n", strings.ToLower(resourceName))
	}

	fmt.Printf("  Output written to: %s\n", serviceDir)
	return nil
}

// generateCommandFiles generates the command YAML file and its partial
func generateCommandFiles(resourceDir, partialsDir, cmdName string, method *api.Method, cfg *gcloudyaml.Config) error {
	topLevelFile := filepath.Join(resourceDir, cmdName+".yaml")
	topLevelContent := "# NOTE: This file is autogenerated and should not be edited by hand.\n_PARTIALS_: true\n"
	if err := os.WriteFile(topLevelFile, []byte(topLevelContent), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", topLevelFile, err)
	}

	apiCfg := findAPIConfig(cfg, method)
	if apiCfg == nil {
		return fmt.Errorf("could not find API config for method %s", method.ID)
	}

	if apiCfg.ReleaseTracks == nil {
		return fmt.Errorf("API config for method %s has nil ReleaseTracks", method.ID)
	}

	for _, track := range apiCfg.ReleaseTracks {
		trackStr := strings.ToLower(string(track))
		partialFile := filepath.Join(partialsDir, fmt.Sprintf("_%s_%s.yaml", cmdName, trackStr))

		cmd := gcloud.GenerateCommand(method, apiCfg, track)

		data, err := yaml.Marshal(cmd)
		if err != nil {
			return fmt.Errorf("failed to marshal command: %w", err)
		}

		content := "# NOTE: This file is autogenerated and should not be edited by hand.\n" +
			"# AUTOGEN_CLI_VERSION: HEAD\n" +
			string(data)

		if err := os.WriteFile(partialFile, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", partialFile, err)
		}
	}

	return nil
}

func findAPIConfig(cfg *gcloudyaml.Config, method *api.Method) *gcloudyaml.API {
	// method.ID is like ".google.cloud.apihub.v1.HostProjectRegistrationService.CreateHostProjectRegistration"
	// We want to extract "apihub" as the product name.
	parts := strings.Split(method.ID, ".")
	if len(parts) < 4 { // Expecting at least "", "google", "cloud", "apihub"
		return nil
	}
	// The product name is typically the fourth part (index 3) in the fully qualified name.
	// e.g., ".google.cloud.apihub.v1.HostProjectRegistrationService.CreateHostProjectRegistration" -> "apihub"
	productName := parts[3]

	for i, apiCfg := range cfg.APIs {
		// apiCfg.Name is like "ApiHub", "LintingService", "InsightsInternal"
		// We need to compare productName (e.g., "apihub") with apiCfg.Name (e.g., "ApiHub") case-insensitively.
		if strings.EqualFold(productName, apiCfg.Name) {
			return &cfg.APIs[i]
		}
	}
	return nil
}
